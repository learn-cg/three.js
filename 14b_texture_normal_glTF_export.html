<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Three Box with Texture Mapping - glTF Export</title>
		<style>body { margin: 0; }</style>
		<script type="importmap">
		{
  			"imports": {
    		"three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    		"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  			}
		}
		</script>
	</head>
	<body>
		<canvas id="HelloCanvas"></canvas>
		<script type="module">
    		import * as THREE from 'three';
			// Import the GLTFExporter
    		import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

			const h_scr = window.innerWidth;
			const v_scr = window.innerHeight;
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(45, h_scr/v_scr, 0.1, 1000);
			camera.position.z = 3;

			const renderer = new THREE.WebGLRenderer({canvas: HelloCanvas, antialias: true});
			renderer.setSize( h_scr, v_scr );

			const geometry = new THREE.BoxGeometry();
			const loader = new THREE.TextureLoader();
			const tex = loader.load('https://raw.githubusercontent.com/learn-cg/three.js/main/image/mucha1.jpg');
			const tex_n = loader.load('https://raw.githubusercontent.com/learn-cg/three.js/main/image/mucha1-grey_normal.png');
			const material1 = new THREE.MeshBasicMaterial(
			{ // color: 0xff0000,
				map: tex });
			
			const material2 = new THREE.MeshPhongMaterial({ 	
				color: 0x00ff00, 
				normalMap: tex_n, // Use normalMap instead of bumpMap
				specular: 0xffffff, 
				shininess : 90.0 });

			material2.normalScale.set(0.8, 0.8); // Adjust the x and y strength
			
			const material3 = new THREE.MeshLambertMaterial(
			{	// color:0x0000ff,
				map: tex 	} );
			const box1 = new THREE.Mesh( geometry, material1 );
			const box2 = new THREE.Mesh( geometry, material2 );
			const box3 = new THREE.Mesh( geometry, material3 );
			box2.position.x = -1.5;
			box3.position.x = 1.5;
			scene.add(box1);
			scene.add(box2);
			scene.add(box3);

			const light = new THREE.DirectionalLight(0xffffff, 1.0);
			const ambient = new THREE.AmbientLight(0x222222, 1.0);
			light.position.set (2,2,2);
			scene.add( light );
			scene.add( ambient );

			// --- glTF Exporter Code ---

			const exporter = new GLTFExporter();
			const link = document.createElement('a'); // Create a download anchor
			link.style.display = 'none';
			document.body.appendChild(link);

			function save( blob, filename ) {
				link.href = URL.createObjectURL( blob );
				link.download = filename;
				link.click();
				URL.revokeObjectURL(link.href); // Free up memory
			}

			function exportGLTF(input) {
				const options = {
					binary: true // Set to true for a self-contained .glb file
				};
				exporter.parse(
					input,
					function ( result ) {
						if ( result instanceof ArrayBuffer ) {
							save( new Blob( [ result ], { type: 'application/octet-stream' } ), 'scene.glb' );
						} else {
							const output = JSON.stringify( result, null, 2 );
							save( new Blob( [ output ], { type: 'text/plain' } ), 'scene.gltf' );
						}
					},
					function ( error ) {
						console.log( 'An error happened during parsing', error );
					},
					options
				);
			}

			// Add keyboard event listener to trigger the export
			document.addEventListener('keydown', (event) => {
				if (event.code === 'Space') {
					console.log("Exporting scene...");
					exportGLTF(scene);
				}
			});

			// --- End of Exporter Code ---


			const animate = function () {
				requestAnimationFrame( animate );
				box1.rotation.x += 0.02;
				box2.rotation.x += 0.01;
				box3.rotation.x += 0.01;
				box1.rotation.y += 0.02;
				box2.rotation.y += 0.01;
				box3.rotation.y += 0.01;
				renderer.render( scene, camera );
			};
			animate();

		</script>
	</body>
</html>